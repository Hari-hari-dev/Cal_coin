<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Solana dApp – Initialize Dapp and Mint</title>
  <!-- Include Buffer polyfill so Buffer.from works -->
  <script src="https://unpkg.com/buffer-polyfill@6.0.3/dist/buffer.umd.cjs"></script>
  <!-- Include Solana web3.js via CDN -->
  <script src="https://unpkg.com/@solana/web3.js@1.98.0/lib/index.iife.min.js"></script>
  <style>
    body { font-family: Arial, sans-serif; margin: 2em; }
    button, input { margin: 0.5em 0; padding: 0.5em; }
  </style>
</head>
<body>
  <h1>Solana dApp – Initialize Dapp and Mint</h1>
  
  <!-- Wallet Connection Section -->
  <button id="connect">Connect Phantom</button>
  <p id="output">Not connected</p>
  
  <hr>
  
  <!-- Initialize Dapp Section -->
  <h2>Initialize Dapp and Mint</h2>
  <p>
    This function will attempt to create the global dapp configuration, set the token mint,
    create a mint authority PDA, and pre-mint commission tokens.
    <br>(Discriminator: eb1eb394b9a87d4b)
  </p>
  <input type="number" id="initAmount" placeholder="Initial Commission Tokens (μtokens)" />
  <button id="initDapp" disabled>Initialize Dapp and Mint</button>
  <p id="initOutput">Dapp not initialized.</p>
  
  <script>
    // --- CONFIGURATION CONSTANTS ---
    const PROGRAM_ID = new solanaWeb3.PublicKey("Ut7RHuZp1PKQ581aa2TpJ39UYgs6vBna6v67RvpS9Ys");
    // The program creates a new mint as a PDA.
    const TOKEN_2022_PROGRAM_ID = new solanaWeb3.PublicKey("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb");
    const ASSOCIATED_TOKEN_PROGRAM_ID = new solanaWeb3.PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");
  
    // Discriminator for initialize_dapp_and_mint (hex: eb1eb394b9a87d4b)
    const DISCRIMINATOR_INIT = Uint8Array.from([0xeb, 0x1e, 0xb3, 0x94, 0xb9, 0xa8, 0x7d, 0x4b]);
  
    // --- HELPER FUNCTIONS ---
    function u64ToBytes(num) {
      const buffer = new ArrayBuffer(8);
      new DataView(buffer).setBigUint64(0, BigInt(num), true);
      return new Uint8Array(buffer);
    }
    
    function getPDA(seeds, programId) {
      return solanaWeb3.PublicKey.findProgramAddressSync(seeds, programId);
    }
    
    function findATA(walletPubkey, mintPubkey) {
      const [ata] = solanaWeb3.PublicKey.findProgramAddressSync(
        [walletPubkey.toBytes(), TOKEN_2022_PROGRAM_ID.toBytes(), mintPubkey.toBytes()],
        ASSOCIATED_TOKEN_PROGRAM_ID
      );
      return ata;
    }
  
    // --- GLOBAL VARIABLES ---
    let wallet, connection;
    let mintForDappPda, dappConfigPda, mintAuthorityPda;
  
    // --- UI ELEMENTS ---
    const connectBtn = document.getElementById("connect");
    const outputEl = document.getElementById("output");
    const initBtn = document.getElementById("initDapp");
    const initAmountInput = document.getElementById("initAmount");
    const initOutput = document.getElementById("initOutput");
  
    // --- CONNECT WALLET ---
    connectBtn.addEventListener("click", async () => {
      try {
        wallet = window.solana;
        await wallet.connect({ onlyIfTrusted: false });
        outputEl.textContent = `Connected: ${wallet.publicKey.toString()}`;
        connection = new solanaWeb3.Connection(solanaWeb3.clusterApiUrl("devnet"), "confirmed");
  
        // Derive mint_for_dapp PDA using seeds: ["my_spl_mint", wallet.publicKey]
        [mintForDappPda] = getPDA([Buffer.from("my_spl_mint"), wallet.publicKey.toBuffer()], PROGRAM_ID);
        // Derive dapp_config PDA using seeds: ["dapp", mint_for_dapp PDA]
        [dappConfigPda] = getPDA([Buffer.from("dapp"), mintForDappPda.toBuffer()], PROGRAM_ID);
        // Derive mint_authority PDA using seeds: ["mint_authority"]
        [mintAuthorityPda] = getPDA([Buffer.from("mint_authority")], PROGRAM_ID);
  
        console.log("PDAs computed:");
        console.log("mintForDappPda:", mintForDappPda.toBase58());
        console.log("dappConfigPda:", dappConfigPda.toBase58());
        console.log("mintAuthorityPda:", mintAuthorityPda.toBase58());
  
        initBtn.disabled = false;
      } catch (err) {
        console.error(err);
        outputEl.textContent = `Error: ${err.message}`;
      }
    });
  
    // --- INITIALIZE DAPP AND MINT ---
    initBtn.addEventListener("click", async () => {
      try {
        const initialCommissionTokens = BigInt(initAmountInput.value);
        if (initialCommissionTokens <= 0n)
          throw new Error("Enter a valid commission token amount.");
  
        // Build instruction data: discriminator || initial_commission_tokens (8-byte LE)
        const commissionBytes = u64ToBytes(initialCommissionTokens);
        const instructionData = new Uint8Array(DISCRIMINATOR_INIT.length + commissionBytes.length);
        instructionData.set(DISCRIMINATOR_INIT, 0);
        instructionData.set(commissionBytes, DISCRIMINATOR_INIT.length);
  
        // Derive commission ATA for the mint_for_dapp PDA and wallet.
        const commissionAta = findATA(wallet.publicKey, mintForDappPda);
  
        // Assemble account keys in the order required by InitializeDappAndMint:
        const keys = [
          { pubkey: dappConfigPda, isSigner: false, isWritable: true },
          { pubkey: mintAuthorityPda, isSigner: false, isWritable: true },
          { pubkey: mintForDappPda, isSigner: false, isWritable: true },
          { pubkey: wallet.publicKey, isSigner: true, isWritable: true },
          { pubkey: commissionAta, isSigner: false, isWritable: true },
          { pubkey: TOKEN_2022_PROGRAM_ID, isSigner: false, isWritable: false },
          { pubkey: ASSOCIATED_TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
          { pubkey: solanaWeb3.SystemProgram.programId, isSigner: false, isWritable: false },
          { pubkey: solanaWeb3.SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },
        ];
  
        const tx = new solanaWeb3.Transaction().add(
          new solanaWeb3.TransactionInstruction({
            programId: PROGRAM_ID,
            keys,
            data: instructionData,
          })
        );
  
        tx.feePayer = wallet.publicKey;
        const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash();
        tx.recentBlockhash = blockhash;
        tx.lastValidBlockHeight = lastValidBlockHeight;
  
        // Force the transaction to compile its message.
        tx.compileMessage();
  
        // Sign the transaction using Phantom.
        const signedTx = await wallet.signTransaction(tx);
  
        // --- Simulation Debugging ---
        try {
          const simResult = await connection.simulateTransaction(signedTx);
          if (simResult.value.err) {
            console.error("Simulation failed:", simResult.value.err);
            if (simResult.value.logs) {
              console.error("Simulation logs:", simResult.value.logs);
            }
            throw new Error("Transaction simulation failed");
          }
        } catch (simErr) {
          console.warn("Simulation error, proceeding to send with skipPreflight: true", simErr);
        }
  
        // Submit the transaction.
        const txid = await connection.sendRawTransaction(signedTx.serialize(), { skipPreflight: true });
        await connection.confirmTransaction(txid, "confirmed");
        initOutput.textContent = `Transaction sent: ${txid}`;
      } catch (err) {
        console.error("Initialize Dapp error:", err);
        initOutput.textContent = `Error initializing dapp: ${err.message}`;
      }
    });
  </script>
</body>
</html>
