<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Solana dApp – Vanilla Phantom Example</title>
    <!-- Include Solana web3.js via CDN -->
    <script src="https://unpkg.com/@solana/web3.js@1.98.0/lib/index.iife.min.js"></script>
    <style>
      body { font-family: Arial, sans-serif; margin: 2em; }
      button { margin: 0.5em 0; padding: 0.5em 1em; }
      input { margin: 0.5em 0; padding: 0.4em; }
      hr { margin: 1em 0; }
    </style>
  </head>
  <body>
    <h1>Solana dApp – Vanilla Phantom Example</h1>
    
    <!-- Wallet Connection -->
    <button id="connectWallet">Connect Phantom Wallet</button>
    <p id="walletAddress">Not connected</p>
    
    <hr>
    
    <!-- Dapp Initialization -->
    <h2>Initialize Dapp</h2>
    <p>This will create the global config, set the token mint, create your mint authority PDA, 
       and mint an initial amount of tokens to your ATA.</p>
    <input type="number" id="initAmount" placeholder="Initial Mint Amount (in μtokens)" />
    <button id="initDapp" disabled>Initialize Dapp</button>
    <p id="dappStatus">Dapp not initialized.</p>
    
    <hr>
    
    <!-- Set Exempt -->
    <h2>Set Exempt Address</h2>
    <input type="text" id="exemptAddress" placeholder="Enter new exempt public key" size="50" />
    <button id="setExempt" disabled>Set Exempt</button>
    <p id="setExemptStatus"></p>
    
    <hr>
    
    <!-- Register User -->
    <h2>Register User</h2>
    <button id="registerUser" disabled>Register User</button>
    <p id="registerStatus"></p>
    
    <hr>
    
    <!-- Claim Tokens -->
    <h2>Claim Tokens</h2>
    <button id="claimTokens" disabled>Claim Tokens</button>
    <p id="claimStatus"></p>
    
    <script>
      // --- CONSTANTS & HELPER FUNCTIONS ---
      
      // Program constants (replace with your actual addresses)
      const PROGRAM_ID = new solanaWeb3.PublicKey("BYJtTQxe8F1Zi41bzWRStVPf57knpst3JqvZ7P5EMjex");
      const TOKEN_MINT = new solanaWeb3.PublicKey("YourTokenMintAddressHere");
      const TOKEN_PROGRAM_ID = new solanaWeb3.PublicKey("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb");
      const ASSOCIATED_TOKEN_PROGRAM_ID = new solanaWeb3.PublicKey("ATokenGPvbhRt7Z8BUGKh9dn1dPnse5xCCom1ULxq");
      
      // Discriminator placeholders (8 bytes each, in decimal)
      const DISCRIMINATOR_INIT = new Uint8Array([0x7f, 0x66, 0x9d, 0xda, 0x92, 0xf1, 0xe6, 0x00]);
      const DISCRIMINATOR_SET_EXEMPT = new Uint8Array([0xf4, 0x49, 0x57, 0xbe, 0xa2, 0x7c, 0x96, 0x18]);
      const DISCRIMINATOR_REGISTER_USER = new Uint8Array([0x02, 0xf1, 0x96, 0xdf, 0x63, 0xd6, 0x74, 0x61]);
      const DISCRIMINATOR_CLAIM = new Uint8Array([0x3e, 0xc6, 0xd6, 0xc1, 0xd5, 0x9f, 0x6c, 0xd2]);
      // Helper: Derive the Associated Token Account (ATA) address.
      async function findAssociatedTokenAddress(walletAddress, tokenMintAddress) {
        const associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID;
        const tokenProgramId = TOKEN_PROGRAM_ID;
        const [ata] = solanaWeb3.PublicKey.findProgramAddressSync(
          [
            walletAddress.toBytes(),
            tokenProgramId.toBytes(),
            tokenMintAddress.toBytes(),
          ],
          associatedTokenProgramId
        );
        return ata;
      }
      
      // Helper: Convert a number to an 8-byte little-endian Uint8Array
      function u64ToBytes(num) {
        const buffer = new ArrayBuffer(8);
        new DataView(buffer).setBigUint64(0, BigInt(num), true);
        return new Uint8Array(buffer);
      }
      
      // Helper: Convert a public key to its 32-byte representation.
      function pubkeyToBytes(pubkey) {
        return pubkey.toBuffer();
      }
      
      // --- GLOBAL VARIABLES ---
      let walletAdapter = null;
      let connection = null;
      
      // PDAs (will be computed after wallet connect)
      let dappConfigPda = null;   // Global config PDA (seed: "dapp_config")
      let mintAuthorityPda = null; // Mint authority PDA (seed: "mint_authority")
      let userPda = null;         // User PDA (seed: "user_pda", wallet)
      
      // --- UI ELEMENTS ---
      const connectWalletButton = document.getElementById("connectWallet");
      const walletAddressDiv = document.getElementById("walletAddress");
      
      const initDappButton = document.getElementById("initDapp");
      const initAmountInput = document.getElementById("initAmount");
      const dappStatusP = document.getElementById("dappStatus");
      
      const setExemptButton = document.getElementById("setExempt");
      const exemptAddressInput = document.getElementById("exemptAddress");
      const setExemptStatusP = document.getElementById("setExemptStatus");
      
      const registerUserButton = document.getElementById("registerUser");
      const registerStatusP = document.getElementById("registerStatus");
      
      const claimTokensButton = document.getElementById("claimTokens");
      const claimStatusP = document.getElementById("claimStatus");
      
      // --- CONNECT WALLET ---
      connectWalletButton.onclick = async () => {
        console.log("connectWalletButton clicked");
        if (window.solana && window.solana.isPhantom) {
          try {
          console.log("Phantom provider found:", window.solana);
            // Pass { onlyIfTrusted: false } to ensure the connection prompt always appears
          await window.solana.connect({ onlyIfTrusted: false });
          walletAdapter = window.solana;
          console.log("Wallet connected:", walletAdapter.publicKey.toString());
          walletAddressDiv.textContent = `Connected: ${walletAdapter.publicKey.toString()}`;

            // Create a connection to Devnet (ensure you're served over HTTPS or on localhost)
          connection = new solanaWeb3.Connection(
              solanaWeb3.clusterApiUrl("devnet"),
              "confirmed"
          );
          // Compute PDAs for global config and mint authority
          const seedConfig = new TextEncoder().encode("dapp_config");
          [dappConfigPda] = solanaWeb3.PublicKey.findProgramAddressSync(
              [seedConfig],
              PROGRAM_ID
          );
          const seedMintAuth = new TextEncoder().encode("mint_authority");
          [mintAuthorityPda] = solanaWeb3.PublicKey.findProgramAddressSync(
              [seedMintAuth],
              PROGRAM_ID
          );

            // Enable the other action buttons
          initDappButton.disabled = false;
          setExemptButton.disabled = false;
          registerUserButton.disabled = false;
          claimTokensButton.disabled = false;
          console.log("PDAs computed:", {
              dappConfigPda: dappConfigPda.toBase58(),
              mintAuthorityPda: mintAuthorityPda.toBase58(),
          });
          } catch (err) {
          console.error("Error connecting Phantom:", err);
          walletAddressDiv.textContent = `Error: ${err.message}`;
          }
        } else {
            walletAddressDiv.textContent = "Phantom wallet not found. Please install it.";
        }
      };

      
      // --- INITIALIZE DAPP ---
      initDappButton.onclick = async () => {
        try {
          const initAmount = Number(initAmountInput.value);
          if (isNaN(initAmount) || initAmount <= 0) {
            dappStatusP.textContent = "Please enter a valid initial mint amount.";
            return;
          }
          // Prepare instruction data:
          // [discriminator (8 bytes)] || [initial_mint_amount (8 bytes little-endian)]
          const initAmountBytes = u64ToBytes(initAmount);
          const initData = new Uint8Array(DISCRIMINATOR_INIT.length + initAmountBytes.length);
          initData.set(DISCRIMINATOR_INIT, 0);
          initData.set(initAmountBytes, DISCRIMINATOR_INIT.length);
          
          // Accounts needed:
          // - dapp_config PDA (will be created)
          // - initializer (wallet)
          // - token_mint (constant TOKEN_MINT)
          // - mint_authority PDA (will be created)
          // - user_ata (associated token account for wallet and TOKEN_MINT)
          // - system_program & rent
          // - (For ATA creation, the program is assumed to use associated token program CPI)
          const userPubkey = walletAdapter.publicKey;
          const userAta = await findAssociatedTokenAddress(userPubkey, TOKEN_MINT);
          
          let tx = new solanaWeb3.Transaction();
          // Create instruction for initialize_dapp (manual construction)
          tx.add(
            new solanaWeb3.TransactionInstruction({
              programId: PROGRAM_ID,
              keys: [
                { pubkey: dappConfigPda, isSigner: false, isWritable: true },
                { pubkey: userPubkey, isSigner: true, isWritable: true },
                { pubkey: TOKEN_MINT, isSigner: false, isWritable: false },
                { pubkey: mintAuthorityPda, isSigner: false, isWritable: true },
                { pubkey: userAta, isSigner: false, isWritable: true },
                { pubkey: solanaWeb3.SystemProgram.programId, isSigner: false, isWritable: false },
                { pubkey: solanaWeb3.SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },
                // Optionally include associated token program if required by your program
                { pubkey: ASSOCIATED_TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
                { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
              ],
              data: initData,
            })
          );
          
          tx.feePayer = userPubkey;
          tx.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;
          const signed = await walletAdapter.signAndSendTransaction(tx);
          dappStatusP.textContent = `Dapp initialized. (Transaction: ${signed.signature})`;
        } catch (err) {
          dappStatusP.textContent = `Error initializing dapp: ${err.message}`;
        }
      };
      
      // --- SET EXEMPT ---
      setExemptButton.onclick = async () => {
        try {
          const newExemptStr = exemptAddressInput.value.trim();
          if (!newExemptStr) {
            setExemptStatusP.textContent = "Please enter a public key.";
            return;
          }
          const newExempt = new solanaWeb3.PublicKey(newExemptStr);
          // Instruction data: [discriminator (8 bytes)] || [newExempt (32 bytes)]
          const exemptData = new Uint8Array(DISCRIMINATOR_SET_EXEMPT.length + 32);
          exemptData.set(DISCRIMINATOR_SET_EXEMPT, 0);
          exemptData.set(newExempt.toBuffer(), DISCRIMINATOR_SET_EXEMPT.length);
          
          let tx = new solanaWeb3.Transaction();
          tx.add(
            new solanaWeb3.TransactionInstruction({
              programId: PROGRAM_ID,
              keys: [
                { pubkey: dappConfigPda, isSigner: false, isWritable: true },
                { pubkey: walletAdapter.publicKey, isSigner: true, isWritable: false },
              ],
              data: exemptData,
            })
          );
          tx.feePayer = walletAdapter.publicKey;
          tx.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;
          const signed = await walletAdapter.signAndSendTransaction(tx);
          setExemptStatusP.textContent = `Exempt address set. (Tx: ${signed.signature})`;
        } catch (err) {
          setExemptStatusP.textContent = `Error setting exempt: ${err.message}`;
        }
      };
      
      // --- REGISTER USER ---
      registerUserButton.onclick = async () => {
        try {
          // Derive the user PDA using seed "user_pda" and the user's public key.
          const seedUser = new TextEncoder().encode("user_pda");
          [userPda] = solanaWeb3.PublicKey.findProgramAddressSync(
            [seedUser, walletAdapter.publicKey.toBuffer()],
            PROGRAM_ID
          );
          // Instruction data: just the discriminator for register_user.
          const regData = DISCRIMINATOR_REGISTER_USER;
          
          let tx = new solanaWeb3.Transaction();
          tx.add(
            new solanaWeb3.TransactionInstruction({
              programId: PROGRAM_ID,
              keys: [
                { pubkey: dappConfigPda, isSigner: false, isWritable: false },
                { pubkey: walletAdapter.publicKey, isSigner: true, isWritable: true },
                // For gateway token, we simply pass the user's wallet here as an example.
                { pubkey: walletAdapter.publicKey, isSigner: false, isWritable: false },
                { pubkey: userPda, isSigner: false, isWritable: true },
                { pubkey: solanaWeb3.SystemProgram.programId, isSigner: false, isWritable: false },
                { pubkey: solanaWeb3.SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },
              ],
              data: regData,
            })
          );
          tx.feePayer = walletAdapter.publicKey;
          tx.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;
          const signed = await walletAdapter.signAndSendTransaction(tx);
          registerStatusP.textContent = `User registered. (Tx: ${signed.signature})`;
        } catch (err) {
          registerStatusP.textContent = `Error registering user: ${err.message}`;
        }
      };
      
      // --- CLAIM TOKENS ---
      claimTokensButton.onclick = async () => {
        try {
          // Derive the user PDA as above.
          const seedUser = new TextEncoder().encode("user_pda");
          [userPda] = solanaWeb3.PublicKey.findProgramAddressSync(
            [seedUser, walletAdapter.publicKey.toBuffer()],
            PROGRAM_ID
          );
          // For this example, assume that the dapp config stored the token mint.
          // We'll use our constant TOKEN_MINT.
          // Derive user's Associated Token Account.
          const userAta = await findAssociatedTokenAddress(walletAdapter.publicKey, TOKEN_MINT);
          // Derive mint authority PDA (already computed in connect phase as mintAuthorityPda)
          
          // Instruction data: just the discriminator for claim.
          const claimData = DISCRIMINATOR_CLAIM;
          
          let tx = new solanaWeb3.Transaction();
          tx.add(
            new solanaWeb3.TransactionInstruction({
              programId: PROGRAM_ID,
              keys: [
                { pubkey: dappConfigPda, isSigner: false, isWritable: false },
                { pubkey: walletAdapter.publicKey, isSigner: true, isWritable: true },
                { pubkey: walletAdapter.publicKey, isSigner: false, isWritable: false }, // gateway token placeholder
                { pubkey: userPda, isSigner: false, isWritable: true },
                { pubkey: TOKEN_MINT, isSigner: false, isWritable: true },
                { pubkey: mintAuthorityPda, isSigner: false, isWritable: true },
                { pubkey: userAta, isSigner: false, isWritable: true },
                { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
                { pubkey: ASSOCIATED_TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
                { pubkey: solanaWeb3.SystemProgram.programId, isSigner: false, isWritable: false },
                { pubkey: solanaWeb3.SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },
              ],
              data: claimData,
            })
          );
          tx.feePayer = walletAdapter.publicKey;
          tx.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;
          const signed = await walletAdapter.signAndSendTransaction(tx);
          claimStatusP.textContent = `Tokens claimed. (Tx: ${signed.signature})`;
        } catch (err) {
          claimStatusP.textContent = `Error claiming tokens: ${err.message}`;
        }
      };
    </script>
  </body>
</html>
